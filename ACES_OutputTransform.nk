set cut_paste_input [stack 0]
push $cut_paste_input
Group {
 name ACES_OutputTransform
 tile_color 0xa57aaaff
 selected true
 xpos -11810
 ypos 638
 addUserKnob {20 ACES_OutputTransform_tab l "ACES OutputTransform"}
 addUserKnob {4 eotf l EOTF t "Electrical to Optical Transfer Function of the monitor." M {"ST-2084 (PQ)" "BT.1886 (Rec.709/2020 settings) " "sRGB (mon_curve w/ presets)" "gamma 2.6" "linear (no EOTF)" HLG OCES ""}}
 eotf "BT.1886 (Rec.709/2020 settings) "
 addUserKnob {7 lum_max l "lum max" t "Display maximum luminance in cd/m^2." R 48 10000}
 lum_max 48
 addUserKnob {7 lum_mid l "lum mid" t "Display midpoint luminance in cd/m^2." R 4.8 15}
 lum_mid 4.8
 addUserKnob {7 lum_min l "lum min" t "Display minimum luminance in cd/m^2." R 0.0001 0.02}
 lum_min 0.02
 addUserKnob {4 display_pri l "display primaries" t "Display encoding primaries." M {Rec.709 Rec.2020 P3D65 AP1}}
 addUserKnob {4 limiting_pri l "limiting primaries" t "Limiting primaries for the output transform." -STARTLINE M {Rec.709 Rec.2020 P3D65 AP1 "" "" ""}}
 addUserKnob {6 stretch_black l "stretch black" t "For hdr outputs: stretch black luminance to a PQ code value of 0" +STARTLINE}
 addUserKnob {6 d60_sim l "d60 sim" t "d60 whitepoint simulation." +STARTLINE}
 addUserKnob {6 legal_range l "legal range" t "Output legal range." -STARTLINE}
}
 BackdropNode {
  inputs 0
  name Electrical_Optical_Transfer_Function
  tile_color 0x232323ff
  label "ACESlib.OutputTransforms.ctl : 185\n// EOTF"
  note_font_size 12
  xpos -2273
  ypos 1924
  bdwidth 2135
  bdheight 1733
  z_order -10
 }
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x3f3f3f01
  label "HDR EOTFs"
  note_font_size 42
  xpos -2202
  ypos 2126
  bdwidth 665
  bdheight 1047
  z_order -5
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x3f3f3f01
  label "SDR EOTFs"
  note_font_size 42
  xpos -1061
  ypos 2126
  bdwidth 879
  bdheight 643
  z_order -5
 }
 BackdropNode {
  inputs 0
  name AP1_to_XYZ
  tile_color 0x232323ff
  label "ACESlib.OutputTransforms.ctl : 90\n// Rendering primaries to XYZ\n"
  note_font_size 12
  xpos -1405
  ypos 651
  bdwidth 380
  bdheight 156
 }
 BackdropNode {
  inputs 0
  name D60_whitepoint_simulation
  tile_color 0x232323ff
  label "ACESlib.OutputTransforms.ctl : 150\n// Scale to avoid clipping when device calibration is different from D60. \n// To simulate D60, unequal code values are sent to the display.\n"
  note_font_size 12
  xpos -1406
  ypos 1416
  bdwidth 393
  bdheight 191
 }
 BackdropNode {
  inputs 0
  name Luminance_to_Linear_Code_Values
  tile_color 0x939393ff
  label "ACESlib.OutputTransforms.ctl : 87\n/*  Scale absolute luminance to linear code value  */\n"
  note_font_size 12
  xpos -1365
  ypos 459
  bdwidth 311
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name Output_Legal_Range
  tile_color 0x232323ff
  label "ACESlib.OutputTransforms.ctl : 216\n"
  note_font_size 12
  xpos -1369
  ypos 3800
  bdwidth 318
  bdheight 176
 }
 BackdropNode {
  inputs 0
  name ST2084_2_HLG_1000nits_f3
  tile_color 0x7f7f7f01
  note_font_size 14
  xpos -2103
  ypos 2598
  bdwidth 467
  bdheight 420
 }
 BackdropNode {
  inputs 0
  name Single_Stage_Tone_Scale
  tile_color 0x7b7b7bff
  label "ACESlib.OutputTransforms.ctl : 82\n// Apply the tonescale independently in rendering-space RGB\n"
  note_font_size 12
  xpos -1395
  ypos 173
  bdwidth 371
  bdheight 229
 }
 BackdropNode {
  inputs 0
  name clamp_negatives
  tile_color 0x313131ff
  label "ACESlib.OutputTransforms.ctl : 174\n// Clip values < 0 (i.e. projecting outside the display primaries)"
  note_font_size 12
  xpos -1406
  ypos 1656
  bdwidth 393
  bdheight 191
 }
 BackdropNode {
  inputs 0
  name dim_surround_gamma_adjustment
  tile_color 0x232323ff
  label "ACESlib.OutputTransforms.ctl : 92\n// Apply gamma adjustment to compensate for dim surround\n"
  note_font_size 12
  xpos -1408
  ypos 843
  bdwidth 383
  bdheight 160
 }
 BackdropNode {
  inputs 0
  name limit_primaries
  tile_color 0x232323ff
  label "ACESlib.OutputTransforms.ctl : 130\n// Gamut limit to limiting primaries\n"
  note_font_size 12
  xpos -1406
  ypos 1030
  bdwidth 384
  bdheight 149
 }
 BackdropNode {
  inputs 0
  name limit_primaries1
  tile_color 0x232323ff
  label "ACESlib.OutputTransforms.ctl : 144\n// CIE XYZ to display encoding primaries\n"
  note_font_size 12
  xpos -1402
  ypos 1220
  bdwidth 384
  bdheight 151
 }
 BackdropNode {
  inputs 0
  name rrt_sweeteners_
  tile_color 0x5d5d5dff
  label "ACESlib.OutputTransforms.ctl : 79\n// RRT sweeteners\n"
  note_font_size 12
  xpos -1422
  ypos -448
  bdwidth 424
  bdheight 512
 }
 BackdropNode {
  inputs 0
  name _EOTF_Switch_
  tile_color 0x3e3e3eff
  label "   // EOTF\n   // 0: ST-2084 (PQ)\n   // 1: BT.1886 (Rec.709/2020 settings)\n   // 2: sRGB (mon_curve w/ presets)\n   //    moncurve_r with gamma of 2.4 and \n         offset of 0.055 matches the EOTF found in IEC 61966-2-1:1999 (sRGB)\n   // 3: gamma 2.6\n   // 4: linear (no EOTF)\n   // 5: HLG\n6: OCES (ssts set to 0.0001, 4.8, 10000 with no EOTF and no monitor scaling = OCES)\n7: sRGB (reduced black contrast)"
  note_font_size 14
  xpos -1494
  ypos 3052
  bdwidth 569
  bdheight 423
  z_order 5
 }
 Input {
  inputs 0
  name Input
  xpos -1250
  ypos -586
 }
 AddChannels {
  channels rgba
  name AddChannels1
  xpos -1250
  ypos -514
 }
 BlinkScript {
  recompileCount 66
  ProgramGroup 1
  KernelDescription "2 \"ACES_rrt_sweetener_glow_module\" iterate pixelWise e3abc6bd55618cadd4541d1f0fdb88f40e0c084339045ccf451e23f9ecd2b7ef 2 \"src\" Read Point \"dst\" Write Point 3 \"RRT_GLOW_GAIN\" Float 1 AAAAAA== \"RRT_GLOW_MID\" Float 1 AAAAAA== \"invert\" Bool 1 AA== 3 \"RRT_GLOW_GAIN\" 1 1 \"RRT_GLOW_MID\" 1 1 \"invert\" 1 1 0"
  kernelSource "kernel ACES_rrt_sweetener_glow_module : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\nparam:\n  // User controllable parameters\n  float RRT_GLOW_GAIN;\n  float RRT_GLOW_MID;\n  bool invert;\n  // \"Glow\" module constants\n  // RRT_GLOW_GAIN = 0.05;\n  // RRT_GLOW_MID = 0.08;\n\n\n  float3 mult_f_f3( float x, float3 rgb) \{\n    return float3(rgb.x*x, rgb.y*x, rgb.z*x);\n  \}\n\n  float min_f3(float3 a) \{\n    return min( a.x, min( a.y, a.z));\n  \}\n\n  float max_f3(float3 a) \{\n    return max( a.x, max( a.y, a.z));\n  \}\n\n  float rgb_2_saturation( float3 rgb ) \{\n    return ( max( max_f3(rgb), 1e-10) - max( min_f3(rgb), 1e-10)) / max( max_f3(rgb), 1e-2);\n  \}\n\n  float sigmoid_shaper( float x) \{\n    float t = max( float(1. - fabs( float(x / 2.))), float(0));\n    float y = 1. + sign(float(x)) * (1. - t * t);\n    return y / 2.;\n  \}\n\n  float rgb_2_yc( float3 rgb, float ycRadiusWeight) \{\n    // keyword arguments don't work with blink.. ycRadiusWeight default if not specified was 1.75\n    float r = rgb.x; \n    float g = rgb.y; \n    float b = rgb.z;\n    float chroma = sqrt(float(b*(b-g)+g*(g-r)+r*(r-b)));\n    return ( b + g + r + ycRadiusWeight * chroma) / 3.;\n  \}\n\n  // ------- Glow module functions\n  float glow_fwd( float ycIn, float glowGainIn, float glowMid) \{\n     float glowGainOut;\n     if (ycIn <= 2./3. * glowMid) \{\n       glowGainOut = glowGainIn;\n     \} else if ( ycIn >= 2. * glowMid) \{\n       glowGainOut = 0.;\n     \} else \{\n       glowGainOut = glowGainIn * (glowMid / ycIn - 1./2.);\n     \}\n     return glowGainOut;\n  \}\n\n  void process() \{\n    float3 aces = float3(src().x, src().y, src().z);\n\n    // --- Glow module --- //\n    float saturation = rgb_2_saturation(aces);\n    float s = sigmoid_shaper( (saturation - 0.4) / 0.2);\n    float ycIn = rgb_2_yc( aces, 1.75);\n    float addedGlow = 1. + glow_fwd( saturation, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\n    aces = mult_f_f3( addedGlow, aces);\n    dst() = float4(aces.x, aces.y, aces.z, src().w);\n  \}\n\};"
  rebuild ""
  ACES_rrt_sweetener_glow_module_RRT_GLOW_GAIN 0.05
  ACES_rrt_sweetener_glow_module_RRT_GLOW_MID 0.08
  rebuild_finalise ""
  name rrt_sweetener_glow_module
  xpos -1250
  ypos -376
 }
 BlinkScript {
  recompileCount 3
  ProgramGroup 1
  KernelDescription "2 \"ACES_rrt_sweeteners\" iterate pixelWise 11f0427fe383ce31aef605a1bd14e7e4578b6128d4f54cd3653f6d4c52600ef3 2 \"src\" Read Point \"dst\" Write Point 5 \"RRT_RED_SCALE\" Float 1 AAAAAA== \"RRT_RED_PIVOT\" Float 1 AAAAAA== \"RRT_RED_HUE\" Float 1 AAAAAA== \"RRT_RED_WIDTH\" Float 1 AAAAAA== \"invert\" Bool 1 AA== 5 \"RRT_RED_SCALE\" 1 1 \"RRT_RED_PIVOT\" 1 1 \"RRT_RED_HUE\" 1 1 \"RRT_RED_WIDTH\" 1 1 \"invert\" 1 1 0"
  kernelSource "kernel ACES_rrt_sweeteners : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\nparam:\n  // User controllable parameters\n  float RRT_RED_SCALE;\n  float RRT_RED_PIVOT;\n  float RRT_RED_HUE;\n  float RRT_RED_WIDTH;\n  bool invert;\n\n  // // Red modifier constants\n  // RRT_RED_SCALE = 0.82;\n  // RRT_RED_PIVOT = 0.03;\n  // RRT_RED_HUE = 0.;\n  // RRT_RED_WIDTH = 135.;\n\n\n  float min_f3(float3 a) \{\n    return min( a.x, min( a.y, a.z));\n  \}\n\n  float max_f3(float3 a) \{\n    return max( a.x, max( a.y, a.z));\n  \}\n\n  float rgb_2_saturation( float3 rgb ) \{\n    return ( max( max_f3(rgb), 1e-10) - max( min_f3(rgb), 1e-10)) / max( max_f3(rgb), 1e-2);\n  \}\n\n  float sigmoid_shaper( float x) \{\n    float t = max( float(1. - fabs( float(x / 2.))), float(0));\n    float y = 1. + sign(float(x)) * (1. - t * t);\n    return y / 2.;\n  \}\n\n  float rgb_2_yc( float3 rgb, float ycRadiusWeight) \{\n    // keyword arguments don't work with blink.. ycRadiusWeight default if not specified was 1.75\n    float r = rgb.x; \n    float g = rgb.y; \n    float b = rgb.z;\n    float chroma = sqrt(float(b*(b-g)+g*(g-r)+r*(r-b)));\n    return ( b + g + r + ycRadiusWeight * chroma) / 3.;\n  \}\n\n  // ------- Glow module functions\n  float glow_fwd( float ycIn, float glowGainIn, float glowMid) \{\n     float glowGainOut;\n     if (ycIn <= 2./3. * glowMid) \{\n       glowGainOut = glowGainIn;\n     \} else if ( ycIn >= 2. * glowMid) \{\n       glowGainOut = 0.;\n     \} else \{\n       glowGainOut = glowGainIn * (glowMid / ycIn - 1./2.);\n     \}\n     return glowGainOut;\n  \}\n\n  // Transformations from RGB to other color representations\n  float rgb_2_hue( float3 rgb) \n  \{\n    // Returns a geometric hue angle in degrees (0-360) based on RGB values.\n    // For neutral colors, hue is undefined and the function will return a quiet NaN value.\n    float hue;\n    if (rgb.x == rgb.y && rgb.y == rgb.z) \{\n      hue = 0.; // RGB triplets where RGB are equal have an undefined hue\n    \} else \{\n      hue = (180./3.14159265359) * atan2( sqrt(3)*(rgb.y-rgb.z), 2*rgb.x-rgb.y-rgb.z);\n    \}\n    if (hue < 0.) hue = hue + 360.;\n    return hue;\n  \}\n\n  float center_hue( float hue, float centerH) \{\n    float hueCentered = hue - centerH;\n    if (hueCentered < -180.) hueCentered = hueCentered + 360.;\n    else if (hueCentered > 180.) hueCentered = hueCentered - 360.;\n    return hueCentered;\n  \}\n\n  float cubic_basis_shaper( float x, float w) \{\n    float M\[4]\[4] = \{ \{ -1./6,  3./6, -3./6,  1./6 \},\n                      \{  3./6, -6./6,  3./6,  0./6 \},\n                      \{ -3./6,  0./6,  3./6,  0./6 \},\n                      \{  1./6,  4./6,  1./6,  0./6 \} \};\n    \n    double knots\[5] = \{ -w/2.,\n                       -w/4.,\n                       0.,\n                       w/4.,\n                       w/2. \};\n    float y = 0;\n    if ((x > knots\[0]) && (x < knots\[4])) \{  \n      float knot_coord = (x - knots\[0]) * 4./w;  \n      int j = knot_coord;\n      float t = knot_coord - j;\n      float monomials\[4] = \{ t*t*t, t*t, t, 1. \};\n      // (if/else structure required for compatibility with CTL < v1.5.)\n      if ( j == 3) \{\n        y = monomials\[0] * M\[0]\[0] + monomials\[1] * M\[1]\[0] + \n            monomials\[2] * M\[2]\[0] + monomials\[3] * M\[3]\[0];\n      \} else if ( j == 2) \{\n        y = monomials\[0] * M\[0]\[1] + monomials\[1] * M\[1]\[1] + \n            monomials\[2] * M\[2]\[1] + monomials\[3] * M\[3]\[1];\n      \} else if ( j == 1) \{\n        y = monomials\[0] * M\[0]\[2] + monomials\[1] * M\[1]\[2] + \n            monomials\[2] * M\[2]\[2] + monomials\[3] * M\[3]\[2];\n      \} else if ( j == 0) \{\n        y = monomials\[0] * M\[0]\[3] + monomials\[1] * M\[1]\[3] + \n            monomials\[2] * M\[2]\[3] + monomials\[3] * M\[3]\[3];\n      \} else \{\n        y = 0.0;\n      \}\n    \}\n    return y * 3/2.;\n  \}\n\n\n  void process() \{\n    float3 aces = float3(src().x, src().y, src().z);\n    float saturation = rgb_2_saturation(aces);\n\n    // --- Red modifier --- //\n    float hue = rgb_2_hue( aces);\n    float centeredHue = center_hue( hue, RRT_RED_HUE);\n    float hueWeight = cubic_basis_shaper( centeredHue, RRT_RED_WIDTH);\n    aces.x = aces.x + hueWeight * saturation * (RRT_RED_PIVOT - aces.x) * (1. - RRT_RED_SCALE);\n\n    dst() = float4(aces.x, aces.y, aces.z, src().w);\n  \}\n\};"
  rebuild ""
  ACES_rrt_sweeteners_RRT_RED_SCALE 0.82
  ACES_rrt_sweeteners_RRT_RED_PIVOT 0.03
  ACES_rrt_sweeteners_RRT_RED_WIDTH 135
  rebuild_finalise ""
  name rrt_sweetener_red_modifier
  xpos -1250
  ypos -328
 }
 Clamp {
  channels rgba
  maximum_enable false
  name ClampMin
  xpos -1250
  ypos -202
 }
 ColorMatrix {
  matrix {
      {0.695452 0.140679 0.163869}
      {0.0447946 0.859671 0.0955343}
      {-0.00552588 0.00402521 1.0015}
    }
  invert true
  name _AP0_to_AP1_
  xpos -1250
  ypos -154
 }
 Clamp {
  maximum 65535
  name clamp_f5
  label "line 56"
  xpos -1250
  ypos -118
 }
 BlinkScript {
  recompileCount 5
  ProgramGroup 1
  KernelDescription "2 \"ACES_rrt_sweetener_global_desat\" iterate pixelWise 9c49cb255d5271381c14770725ddc0760348841285984cb906c2a30f57e5e8a6 2 \"src\" Read Point \"dst\" Write Point 1 \"RRT_SAT_FACTOR\" Float 1 AAAAAA== 1 \"RRT_SAT_FACTOR\" 1 1 2 \"AP1_RGB2Y\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"RRT_SAT_MAT\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_rrt_sweetener_global_desat : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\nparam:\n  // User controllable parameters\n  float RRT_SAT_FACTOR;\n  // // Desaturation constants\n  // RRT_SAT_FACTOR = 0.96;\n\nlocal:\n  float3 AP1_RGB2Y;\n  float3x3 RRT_SAT_MAT;\n\n  float3 mult_f3_f33( float3 src, float3x3 mtx) \{\n    return float3(mtx\[0]\[0] * src.x + mtx\[0]\[1] * src.y + \n    mtx\[0]\[2] * src.z, mtx\[1]\[0] * src.x + mtx\[1]\[1] * src.y + \n    mtx\[1]\[2] * src.z, mtx\[2]\[0] * src.x + mtx\[2]\[1] * src.y + \n    mtx\[2]\[2] * src.z);\n  \}\n\n  float3x3 calc_sat_adjust_matrix( float sat, float3 rgb2Y) \{\n    // This function determines the terms for a 3x3 saturation matrix\n    // based on the luminance of the input.\n    float3x3 M;\n    M\[0]\[0] = (1.0 - sat) * rgb2Y.x + sat;\n    M\[1]\[0] = (1.0 - sat) * rgb2Y.x;\n    M\[2]\[0] = (1.0 - sat) * rgb2Y.x;\n    \n    M\[0]\[1] = (1.0 - sat) * rgb2Y.y;\n    M\[1]\[1] = (1.0 - sat) * rgb2Y.y + sat;\n    M\[2]\[1] = (1.0 - sat) * rgb2Y.y;\n    \n    M\[0]\[2] = (1.0 - sat) * rgb2Y.z;\n    M\[1]\[2] = (1.0 - sat) * rgb2Y.z;\n    M\[2]\[2] = (1.0 - sat) * rgb2Y.z + sat;\n\n    M = M.transpose();\n    return M;\n  \} \n\n\n  void init() \{\n    // center line from AP1_2_XYZ_MAT is as follows: see \n    // https://github.com/ampas/aces-dev/blob/master/transforms/ctl/README-MATRIX.md\n    AP1_RGB2Y = float3(0.2722287168, 0.6740817658, 0.0536895174);\n    RRT_SAT_MAT = calc_sat_adjust_matrix( RRT_SAT_FACTOR, AP1_RGB2Y);\n  \}\n\n\n  void process() \{\n    float3 aces = float3(src().x, src().y, src().z);\n\n    // --- Global desaturation --- //\n    aces = mult_f3_f33( aces, RRT_SAT_MAT);\n\n    dst() = float4(aces.x, aces.y, aces.z, src().w);\n\n  \}\n\};"
  rebuild ""
  ACES_rrt_sweetener_global_desat_RRT_SAT_FACTOR 0.96
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -1250
  ypos -16
 }
set N10f99880 [stack 0]
 BlinkScript {
  recompileCount 430
  ProgramGroup 1
  KernelDescription "2 \"AcesSSTSKernel\" iterate componentWise bd2118da93c6393dafdbccc8717144376fbf1628da7c4654d2ac089ce67d5aef 2 \"src\" Read Point \"dst\" Write Point 7 \"disp_lum\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"override_curve_params\" Bool 1 AA== \"knee\" Float 1 AAAAAA== \"shoulder\" Float 1 AAAAAA== \"slope\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"exposure\" Float 1 AAAAAA== \"invert\" Bool 1 AA== 7 \"disp_lum\" 3 1 \"override_curve_params\" 1 1 \"knee\" 1 1 \"shoulder\" 1 1 \"slope\" 3 1 \"exposure\" 1 1 \"invert\" 1 1 17 \"MIN_STOP_SDR\" Float 1 1 AAAAAA== \"MAX_STOP_SDR\" Float 1 1 AAAAAA== \"MIN_STOP_RRT\" Float 1 1 AAAAAA== \"MAX_STOP_RRT\" Float 1 1 AAAAAA== \"MIN_LUM_SDR\" Float 1 1 AAAAAA== \"MAX_LUM_SDR\" Float 1 1 AAAAAA== \"MIN_LUM_RRT\" Float 1 1 AAAAAA== \"MAX_LUM_RRT\" Float 1 1 AAAAAA== \"Min\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"Mid\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"Max\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"expShift\" Float 1 1 AAAAAA== \"coefsLow\" Float 1 5 AAAAAAAAAAAAAAAAAAAAAAAAAAA= \"coefsHigh\" Float 1 5 AAAAAAAAAAAAAAAAAAAAAAAAAAA= \"N_KNOTS_LOW\" Int 1 1 AAAAAA== \"N_KNOTS_HIGH\" Int 1 1 AAAAAA== \"M1\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel AcesSSTSKernel : public ImageComputationKernel<eComponentWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\nparam:\n  // User controllable parameters\n  float3 disp_lum;\n  bool override_curve_params;\n  float knee;\n  float shoulder;\n  float3 slope;\n  float exposure;\n  bool invert;\n\nlocal:\n  float MIN_STOP_SDR;\n  float MAX_STOP_SDR;\n  float MIN_STOP_RRT;\n  float MAX_STOP_RRT;\n  float MIN_LUM_SDR;\n  float MAX_LUM_SDR;\n  float MIN_LUM_RRT;\n  float MAX_LUM_RRT;\n  float3 Min;\n  float3 Mid;\n  float3 Max;\n  float expShift;\n  float coefsLow\[5];\n  float coefsHigh\[5];\n  int N_KNOTS_LOW;\n  int N_KNOTS_HIGH;\n  float3x3 M1;\n\n  // -------------------------------------------------------\n  // Utility Functions\n  // -------------------------------------------------------\n\n  // 1D interpolate: return y value at some point p in x\n  // This function differs from the interpolate1D CTL implementation.\n  // It is limited to 2 float2 vectors, x and y\n  // given a position p between x.x and x.y, it returns an interpolated\n  // value between y.x and y.y\n  // CTL_table\[2]\[2] = \{ \{ A, B \}, \{ C, D \} \};\n  // = \n  // float2 x = float2(A, C)\n  // float2 y = float2(B, D)\n  float interpolate1D(float2 x, float2 y, float p) \{\n    if (p <= x.x) \{\n      return y.x;\n    \} else if (p >= x.y) \{\n      return y.y;\n    \} else \{\n      float slope = (y.y-y.x) / (x.y-x.x);\n      return y.x + slope * (p-x.x);\n    \}\n  \}\n\n  // multiply a float3 by a matrix3x3\n  float3 mult_f3_f33( float3 src, float3x3 mtx) \{\n    return float3(mtx\[0]\[0] * src.x + mtx\[0]\[1] * src.y + \n    mtx\[0]\[2] * src.z, mtx\[1]\[0] * src.x + mtx\[1]\[1] * src.y + \n    mtx\[1]\[2] * src.z, mtx\[2]\[0] * src.x + mtx\[2]\[1] * src.y + \n    mtx\[2]\[2] * src.z);\n  \}\n\n  // dot product of two 1x3 matrices\n  float dot_f3_f3( float3 A, float3 B) \{\n    return (A.x*B.x)+(A.y*B.y)+(A.z*B.z);\n  \}\n\n  // Return interpolated minimum ACES value given a minimum luminance value.\n  float lookup_ACESmin( float minLum ) \{\n    float2 rangeLum = float2(log10(float(MIN_LUM_RRT)), log10(float(MIN_LUM_SDR)));\n    float2 rangeStops = float2(MIN_STOP_RRT, MIN_STOP_SDR);\n    return 0.18*pow( float(2), float(interpolate1D( rangeLum, rangeStops, log10( float(minLum)))));\n  \}\n  // Return interpolated maximum ACES value given a maximum luminance value.\n  float lookup_ACESmax( float maxLum ) \{\n    float2 rangeLum = float2(log10(float(MAX_LUM_SDR)), log10(float(MAX_LUM_RRT)));\n    float2 rangeStops = float2(MAX_STOP_SDR, MAX_STOP_RRT);\n    return 0.18*pow( float(2), float(interpolate1D( rangeLum, rangeStops, log10( float(maxLum)))));\n  \}\n\n  void init_coefsLow( float3 TsPointLow, float3 TsPointMid ) \{\n    // :145 float cLow\[5] = init_coefsLow( MIN_PT, MID_PT);\n    float knotIncLow = (log10(TsPointMid.x) - log10(TsPointLow.x)) / 3.0;\n    // DeterTsPointLowe two lowest coefficients (straddling TsPointLowPt)\n    coefsLow\[0] = (TsPointLow.z * (log10(float(TsPointLow.x))-0.5*knotIncLow)) + ( log10(float(TsPointLow.y)) - TsPointLow.z * log10(float(TsPointLow.x)));\n    coefsLow\[1] = (TsPointLow.z * (log10(float(TsPointLow.x))+0.5*knotIncLow)) + ( log10(float(TsPointLow.y)) - TsPointLow.z * log10(float(TsPointLow.x)));\n    // DeterTsPointLowe two highest coefficients (straddling TsPointMidPt)\n    coefsLow\[3] = (TsPointMid.z * (log10(float(TsPointMid.x))-0.5*knotIncLow)) + ( log10(float(TsPointMid.y)) - TsPointMid.z * log10(float(TsPointMid.x)));\n    coefsLow\[4] = (TsPointMid.z * (log10(float(TsPointMid.x))+0.5*knotIncLow)) + ( log10(float(TsPointMid.y)) - TsPointMid.z * log10(float(TsPointMid.x)));\n    // TsPointMiddle coefficient (which defines the \"sharpness of the bend\") is linearly interpolated\n    float2 bendsLowA = float2(MIN_STOP_RRT, MIN_STOP_SDR);\n    float2 bendsLowB = float2(0.18, 0.35);\n    float pctLow;\n    if (override_curve_params == 1) \{\n      pctLow = knee;\n    \}\n    else \{\n      pctLow = interpolate1D(bendsLowA, bendsLowB, log2(float(TsPointLow.x/0.18)));\n    \}\n    coefsLow\[2] = log10(float(TsPointLow.y)) + pctLow*(log10(float(TsPointMid.y))-log10(float(TsPointLow.y)));\n  \}\n\n  void init_coefsHigh( float3 TsPointMid, float3 TsPointMax ) \{\n    // :146 float cHigh\[5] = init_coefsHigh( MID_PT, MAX_PT);\n    float knotIncHigh = (log10(TsPointMax.x) - log10(TsPointMid.x)) / 3.;\n    // DeterMine two lowest coefficients (straddling MidPt)\n    coefsHigh\[0] = (TsPointMid.z * (log10(float(TsPointMid.x))-0.5*knotIncHigh)) + ( log10(float(TsPointMid.y)) - TsPointMid.z * log10(float(TsPointMid.x)));\n    coefsHigh\[1] = (TsPointMid.z * (log10(float(TsPointMid.x))+0.5*knotIncHigh)) + ( log10(float(TsPointMid.y)) - TsPointMid.z * log10(float(TsPointMid.x)));\n    // DeterMide two highest coefficients (straddling TsPointMaxPt)\n    coefsHigh\[3] = (TsPointMax.z * (log10(float(TsPointMax.x))-0.5*knotIncHigh)) + ( log10(float(TsPointMax.y)) - TsPointMax.z * log10(float(TsPointMax.x)));\n    coefsHigh\[4] = (TsPointMax.z * (log10(float(TsPointMax.x))+0.5*knotIncHigh)) + ( log10(float(TsPointMax.y)) - TsPointMax.z * log10(float(TsPointMax.x)));\n    // Middle coefficient (which defines the \"sharpness of the bend\") is linearly interpolated\n    float2 bendsHighA = float2(MAX_STOP_SDR, MAX_STOP_RRT);\n    float2 bendsHighB = float2(0.89, 0.90);\n    float pctHigh;\n    if (override_curve_params == 1) \{\n      pctHigh = shoulder;\n    \}\n    else \{\n      pctHigh = interpolate1D(bendsHighA, bendsHighB, log2(float(TsPointMax.x/0.18)));\n    \}\n    coefsHigh\[2] = log10(float(TsPointMid.y)) + pctHigh*(log10(float(TsPointMax.y))-log10(float(TsPointMid.y)));\n  \}\n\n  float shift( float in, float expShift) \{\n    return pow(float(2), (log2(float(in)) - expShift));\n  \}\n\n  void init_TsParams( float minLum, float maxLum, float exp_shift ) \{\n    // ACESlib.SSTS.ctl :136 init_TsParams \n    // Min Mid and Max is a float3 :\n    // x = lum (aces), y = lum (cd/m^2), z = slope\n\n    // override slope with default values used in AMPAS CTL\n    if (override_curve_params == 1) \{\n      Min = float3(lookup_ACESmin(minLum), minLum, float(slope.x));\n      Mid = float3(0.18, 4.8, float(slope.y));\n      Max = float3(lookup_ACESmax(maxLum), maxLum, float(slope.z));   \n    \}\n    else \{\n      Min = float3(lookup_ACESmin(minLum), minLum, float(0.0));\n      Mid = float3(0.18, 4.8, float(1.55));\n      Max = float3(lookup_ACESmax(maxLum), maxLum, float(0.0));\n    \}\n\n    // init coefsLow and coefsHigh (directly sets local variables).\n    init_coefsLow( Min, Mid );\n    init_coefsHigh( Mid, Max );\n\n    // :140 - init_TsParams : Exposure Shift\n    Min.x = shift(lookup_ACESmin(minLum), exp_shift);\n    Mid.x = shift(0.18, exp_shift);\n    Max.x = shift(lookup_ACESmax(maxLum), exp_shift);\n\n    // PARAMS = \n    // float3 Min / float3 Mid / float3 Max \n    // coefsLow\[5]\n    // coefsHigh\[5]\n  \}\n\n  void init() \{\n    // Textbook monomial to basis-function conversion matrix. (Used in tonescale)\n    MIN_STOP_SDR = -6.5;\n    MAX_STOP_SDR = 6.5;\n    MIN_STOP_RRT = -15.;\n    MAX_STOP_RRT = 18.;\n    MIN_LUM_SDR = 0.02;\n    MAX_LUM_SDR = 48.0;\n    MIN_LUM_RRT = 0.0001;\n    MAX_LUM_RRT = 10000.0;\n    // Monomial to basis function\n    float Marray\[] = \{0.5, -1.0, 0.5, \n                      -1.0, 1.0, 0.0, \n                      0.5, 0.5, 0.0\};\n    M1.setArray(Marray);\n\n    N_KNOTS_LOW = 4;\n    N_KNOTS_HIGH = 4;\n\n    // Get min / max lum from user\n    float Y_MIN = disp_lum.x;\n    float Y_MID = disp_lum.y;\n    float Y_MAX = disp_lum.z;\n\n\n    init_TsParams( Y_MIN, Y_MAX, 0.0 );\n\n    // Define expShift from inv_ssts\n    expShift = (log2(inv_ssts(Y_MID)) - log2(0.18)) + exposure;\n\n    // expShift = log2(inv_ssts(Y_MID)) - log2(0.18);\n\n    init_TsParams( Y_MIN, Y_MAX, expShift );\n  \}\n\n\n  // ACES Single Stage Tone Scale\n  float ssts( float x ) \{\n\n    // Take the log: clamp min to HALF_MIN\n    float logx = log10(max(x, 5.96046448e-08));\n    float logy;\n\n    // Calculate values for linear extension in shadows\n    if (logx <= log10(float(Min.x))) \{\n      logy = logx * Min.z + (log10(float(Min.y))) - \n        Min.z * log10(float(Min.x));\n    \}\n    // Calculate values for lower half of S-curve, shadows \n    else if (( logx > log10(float(Min.x)) ) && ( logx < log10(float(Mid.x)) )) \{\n      float knot_coord = (N_KNOTS_LOW-1) * (logx-log10(float(Min.x)))/\n        (log10(float(Mid.x))-log10(float(Min.x)));\n      int j = knot_coord;\n      float t = knot_coord - j;\n      float3 cf = float3(coefsLow\[j], coefsLow\[j + 1], coefsLow\[j + 2]);\n      float3 monomials = float3(t * t, t, 1.);\n      logy = dot_f3_f3(monomials, mult_f3_f33(cf, M1));\n    \}\n    // Calculate values for upper half of S-curve, highlights\n    else if (( logx >= log10(float(Mid.x)) ) && ( logx < log10(float(Max.x)) )) \{\n      float knot_coord = (N_KNOTS_HIGH-1) * (logx-log10(float(Mid.x)))/\n        (log10(float(Max.x))-log10(float(Mid.x)));\n      int j = knot_coord;\n      float t = knot_coord - j;\n      float3 cf = float3(coefsHigh\[j], coefsHigh\[j + 1], coefsHigh\[j + 2]); \n      float3 monomials = float3(t * t, t, 1.);\n      logy = dot_f3_f3(monomials, mult_f3_f33(cf, M1));\n    \}\n    // Calculate values for linear extension in highlights\n    else \{ // if ( logx >= log10(float(Max.x)) ) \{\n      logy = logx * Max.z + ( log10(float(Max.y)) - Max.z * log10(float(Max.x)) );\n    \}\n    // un-log\n    return  pow(float(10),logy);\n  \}\n\n\n  // ACES Inverse Single Stage Tone Scale\n  float inv_ssts( float y ) \{\n\n    float KNOT_INC_LOW = (log10(float(Mid.x)) - log10(float(Min.x))) / (N_KNOTS_LOW - 1.);\n    float KNOT_INC_HIGH = (log10(float(Max.x)) - log10(float(Mid.x))) / (N_KNOTS_HIGH - 1.);\n\n    // KNOT_Y is luminance of the spline at each knot\n    // Error 1: variable length arrays are not supported in OpenCL\n    // float __KNOT_Y_LOW_38\[N_KNOTS_LOW];\n    // Setting array length to 4 manually as a workaround... :(\n    float KNOT_Y_LOW\[ 4];\n    for (int i = 0; i < N_KNOTS_LOW; i = i+1) \{\n      KNOT_Y_LOW\[ i] = ( coefsLow\[i] + coefsLow\[i+1]) / 2.;\n    \}\n    // Setting array length to 4 manually as a workaround...\n    float KNOT_Y_HIGH\[ 4];\n    for (int i = 0; i < N_KNOTS_HIGH; i = i+1) \{\n      KNOT_Y_HIGH\[ i] = ( coefsHigh\[i] + coefsHigh\[i+1]) / 2.;\n    \};\n\n    float logy = log10( max(y, 1e-10));\n    float logx;\n\n    if (logy <= log10(float(Min.y))) \{\n        logx = log10(float(Min.x));\n\n    \} else if ( (logy > log10(float(Min.y))) && (logy <= log10(float(Mid.y))) ) \{\n        int j;\n        float3 cf;\n        if ( logy > KNOT_Y_LOW\[ 0] && logy <= KNOT_Y_LOW\[ 1]) \{\n            cf.x = coefsLow\[0];  cf.y = coefsLow\[1];  cf.z = coefsLow\[2];  j = 0;\n        \} else if ( logy > KNOT_Y_LOW\[ 1] && logy <= KNOT_Y_LOW\[ 2]) \{\n            cf.x = coefsLow\[1];  cf.y = coefsLow\[2];  cf.z = coefsLow\[3];  j = 1;\n        \} else if ( logy > KNOT_Y_LOW\[ 2] && logy <= KNOT_Y_LOW\[ 3]) \{\n            cf.x = coefsLow\[2];  cf.y = coefsLow\[3];  cf.z = coefsLow\[4];  j = 2;\n        \} \n\n        float3 tmp = mult_f3_f33( cf, M1);\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        const float d = sqrt(float(b * b - 4. * a * c));\n\n        const float t = ( 2. * c) / ( -d - b);\n\n        logx = log10(float(Min.x)) + ( t + j) * KNOT_INC_LOW;\n\n    \} else if ( (logy > log10(float(Mid.y))) && (logy < log10(float(Max.y))) ) \{\n        int j;\n        float3 cf;\n        if ( logy >= KNOT_Y_HIGH\[ 0] && logy <= KNOT_Y_HIGH\[ 1]) \{\n            cf.x = coefsHigh\[0];  cf.y = coefsHigh\[1];  cf.z = coefsHigh\[2];  j = 0;\n        \} else if ( logy > KNOT_Y_HIGH\[ 1] && logy <= KNOT_Y_HIGH\[ 2]) \{\n            cf.x = coefsHigh\[1];  cf.y = coefsHigh\[2];  cf.z = coefsHigh\[3];  j = 1;\n        \} else if ( logy > KNOT_Y_HIGH\[ 2] && logy <= KNOT_Y_HIGH\[ 3]) \{\n            cf.x = coefsHigh\[2];  cf.y = coefsHigh\[3];  cf.z = coefsHigh\[4];  j = 2;\n        \} \n\n        float3 tmp = mult_f3_f33( cf, M1);\n\n        float a = tmp.x;\n        float b = tmp.y;\n        float c = tmp.z;\n        c = c - logy;\n\n        const float d = sqrt( float(b * b - 4. * a * c));\n\n        const float t = ( 2. * c) / ( -d - b);\n\n        logx = log10(float(Mid.x)) + ( t + j) * KNOT_INC_HIGH;\n\n    \} else \{ //if ( logy >= log10(float(Max.y)) ) \{\n\n        logx = log10(float(Max.x));\n\n    \}\n\n    return pow(10, logx);\n\n  \}\n\n  void process() \{\n\n    if (invert == 1 ) \{\n      dst() = inv_ssts(src());\n    \}\n    else \{\n      dst() = ssts(src());\n    \}\n  \}\n\};"
  rebuild ""
  AcesSSTSKernel_disp_lum {{parent.lum_min} {parent.lum_mid} {parent.lum_max}}
  AcesSSTSKernel_knee 0.89
  AcesSSTSKernel_shoulder 0.91
  AcesSSTSKernel_slope {0 1.55 0}
  rebuild_finalise ""
  name aces_ssts_blink1
  xpos -1250
  ypos 272
 }
 Expression {
  expr0 "(r - Ymin) / (Ymax - Ymin)"
  expr1 "(g - Ymin) / (Ymax - Ymin)"
  expr2 "(b - Ymin) / (Ymax - Ymin)"
  name Y_2_linCV_f3
  xpos -1250
  ypos 542
  addUserKnob {20 Luminance}
  addUserKnob {7 Ymax R 48 10000}
  Ymax {{parent.lum_max}}
  addUserKnob {7 Ymin R 0.0001 0.02}
  Ymin {{parent.lum_min}}
 }
 Clamp {
  channels rgb
  maximum 65535
  name clamp_f1
  xpos -1250
  ypos 1766
 }
 Dot {
  name Dot1
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1216
  ypos 2226
 }
set N10ffa8f0 [stack 0]
 Dot {
  name Dot6
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -886
  ypos 2226
 }
set N10fffe10 [stack 0]
 Expression {
  temp_name0 yb
  temp_expr0 "pow( offs * gamma / ( ( gamma - 1.0) * ( 1.0 + offs)), gamma)"
  temp_name1 rs
  temp_expr1 "pow( ( gamma - 1.0) / offs, gamma - 1.0) * pow( ( 1.0 + offs) / gamma, gamma)"
  expr0 "r >= yb ? ( 1.0 + offs) * pow( r, 1.0 / gamma) - offs : r * rs"
  expr1 "g >= yb ? ( 1.0 + offs) * pow( g, 1.0 / gamma) - offs : g * rs"
  expr2 "b >= yb ? ( 1.0 + offs) * pow( b, 1.0 / gamma) - offs : b * rs"
  name moncurve_r_f3_liftblacks
  label "ACESlib.Utilities_Color.ctl : 260\n// Reverse monitor curve"
  xpos -920
  ypos 2402
  addUserKnob {20 Luminance}
  addUserKnob {7 gamma R 0 4}
  gamma 2.2
  addUserKnob {7 offs}
  offs 0.02
 }
push $N10ffa8f0
 Dot {
  name Dot2
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1876
  ypos 2226
 }
set N11013ac0 [stack 0]
 Expression {
  expr0 "r * (Ymax - Ymin) + Ymin"
  expr1 "g * (Ymax - Ymin) + Ymin"
  expr2 "b * (Ymax - Ymin) + Ymin"
  name linCV_2_Y_f3
  label "stretch_black = True"
  xpos -2020
  ypos 2288
  addUserKnob {20 Luminance}
  addUserKnob {7 Ymax R 48 10000}
  Ymax {{parent.lum_max}}
  addUserKnob {7 Ymin R 0.0001 0.02}
 }
push $N11013ac0
 Expression {
  expr0 "r * (Ymax - Ymin) + Ymin"
  expr1 "g * (Ymax - Ymin) + Ymin"
  expr2 "b * (Ymax - Ymin) + Ymin"
  name linCV_2_Y_f1
  label "stretch_black = False"
  xpos -1910
  ypos 2288
  addUserKnob {20 Luminance}
  addUserKnob {7 Ymax R 48 10000}
  Ymax {{parent.lum_max}}
  addUserKnob {7 Ymin R 0.0001 0.02}
  Ymin {{parent.lum_min}}
 }
 Switch {
  inputs 2
  which {{parent.stretch_black}}
  name StretchBlacks_Switch
  xpos -1910
  ypos 2366
 }
 Clamp {
  channels rgb
  maximum 65535
  name clamp_f3
  xpos -1910
  ypos 2438
 }
 Expression {
  temp_name0 Lm_r
  temp_expr0 "pow((r / pq_C), pq_m1)"
  temp_name1 Lm_g
  temp_expr1 "pow((g / pq_C), pq_m1)"
  temp_name2 Lm_b
  temp_expr2 "pow((b / pq_C), pq_m1)"
  expr0 "pow(( pq_c1 + pq_c2 * Lm_r ) / ( 1.0 + pq_c3 * Lm_r ), pq_m2)"
  expr1 "pow(( pq_c1 + pq_c2 * Lm_g ) / ( 1.0 + pq_c3 * Lm_g ), pq_m2)"
  expr2 "pow(( pq_c1 + pq_c2 * Lm_b ) / ( 1.0 + pq_c3 * Lm_b ), pq_m2)"
  name Y_2_ST2084
  label "ACESlib.OutputTransforms.ctl : 243 \nACESlib.Utilities_Color.ctl : 425"
  xpos -1910
  ypos 2498
  addUserKnob {20 SMPTE_ST2084-2014_Constants_tab l "Constants from SMPTE ST 2084-2014"}
  addUserKnob {7 pq_m1 t " ( 2610.0 / 4096.0 ) / 4.0;" +DISABLED R 0 100}
  pq_m1 0.1593017578
  addUserKnob {7 pq_m2 t " ( 2523.0 / 4096.0 ) * 128.0;" +DISABLED R 0 100}
  pq_m2 78.84375
  addUserKnob {7 pq_c1 t " 3424.0 / 4096.0 or pq_c3 - pq_c2 + 1.0;" +DISABLED R 0 100}
  pq_c1 0.8359375
  addUserKnob {7 pq_c2 t " ( 2413.0 / 4096.0 ) * 32.0;" +DISABLED R 0 100}
  pq_c2 18.8515625
  addUserKnob {7 pq_c3 t " ( 2392.0 / 4096.0 ) * 32.0;" +DISABLED R 0 100}
  pq_c3 18.6875
  addUserKnob {7 pq_C +DISABLED R 0 100}
  pq_C 10000
 }
set N1104d610 [stack 0]
 Expression {
  temp_name0 Np_r
  temp_expr0 "pow( r, 1.0 / pq_m2 )"
  temp_name1 Np_g
  temp_expr1 "pow( g, 1.0 / pq_m2 )"
  temp_name2 Np_b
  temp_expr2 "pow( b, 1.0 / pq_m2 )"
  expr0 "r < 0 ? 0 : pow((Np_r - pq_c1) / ( pq_c2 - pq_c3 * Np_r ), 1.0/pq_m1) * pq_C"
  expr1 "g < 0 ? 0 : pow((Np_g - pq_c1) / ( pq_c2 - pq_c3 * Np_g ), 1.0/pq_m1) * pq_C"
  expr2 "b < 0 ? 0 : pow((Np_b - pq_c1) / ( pq_c2 - pq_c3 * Np_b ), 1.0/pq_m1) * pq_C"
  name ST2084_2_Y_f3
  label "ACESlib.Utilities_Color.ctl : 408\n// Converts from the non-linear perceptually quantized space to linear cd/m^2"
  xpos -1910
  ypos 2666
  addUserKnob {20 SMPTE_ST2084-2014_Constants_tab l "Constants from SMPTE ST 2084-2014"}
  addUserKnob {7 pq_m1 t " ( 2610.0 / 4096.0 ) / 4.0;" +DISABLED R 0 100}
  pq_m1 0.1593017578
  addUserKnob {7 pq_m2 t " ( 2523.0 / 4096.0 ) * 128.0;" +DISABLED R 0 100}
  pq_m2 78.84375
  addUserKnob {7 pq_c1 t " 3424.0 / 4096.0 or pq_c3 - pq_c2 + 1.0;" +DISABLED R 0 100}
  pq_c1 0.8359375
  addUserKnob {7 pq_c2 t " ( 2413.0 / 4096.0 ) * 32.0;" +DISABLED R 0 100}
  pq_c2 18.8515625
  addUserKnob {7 pq_c3 t " ( 2392.0 / 4096.0 ) * 32.0;" +DISABLED R 0 100}
  pq_c3 18.6875
  addUserKnob {7 pq_C +DISABLED R 0 100}
  pq_C 10000
 }
 Expression {
  temp_name0 Y_d
  temp_expr0 "0.2627*r + 0.6780*g + 0.0593*b"
  expr0 "Y_d == 0 ? 0 : pow( (Y_d-c_beta)/c_alpha, (1-c_gamma)/c_gamma) * ((r-c_beta)/c_alpha)"
  expr1 "Y_d == 0 ? 0 : pow( (Y_d-c_beta)/c_alpha, (1-c_gamma)/c_gamma) * ((g-c_beta)/c_alpha)"
  expr2 "Y_d == 0 ? 0 : pow( (Y_d-c_beta)/c_alpha, (1-c_gamma)/c_gamma) * ((b-c_beta)/c_alpha)"
  name ST2084_2_HLG_1000nits_f3_3
  label "ACESlib.Utilities_Color.ctl : 469\n// HLG Inverse EOTF (i.e. HLG inverse OOTF followed by the HLG OETF)\n// HLG Inverse OOTF (display linear to scene linear)"
  xpos -1910
  ypos 2792
  addUserKnob {20 Constants_tab l Constants}
  addUserKnob {7 L_w +DISABLED}
  L_w 1000
  addUserKnob {7 L_b +DISABLED}
  addUserKnob {7 c_alpha +DISABLED}
  c_alpha {{L_w-L_b}}
  addUserKnob {7 c_beta +DISABLED}
  c_beta {{L_b}}
  addUserKnob {7 c_gamma +DISABLED}
  c_gamma 1.2
 }
 Expression {
  channel0 {rgba.red -rgba.green -rgba.blue none}
  expr0 "r <= 1.0/12 ? sqrt(3.0*r) : c_a * log(12.0 * r - c_b) + c_c"
  expr1 "g <= 1.0/12 ? sqrt(3.0*g) : c_a * log(12.0 * g- c_b) + c_c"
  expr2 "b <= 1.0/12 ? sqrt(3.0*b) : c_a * log(12.0 * b - c_b) + c_c"
  name ST2084_2_HLG_1000nits_f3_
  label "ACESlib.Utilities_Color.ctl : 493\n// HLG OETF (scene linear to non-linear signal value)"
  xpos -1910
  ypos 2882
  addUserKnob {20 Constants_tab l Constants}
  addUserKnob {7 c_a +DISABLED}
  c_a 0.17883277
  addUserKnob {7 c_b t 1.-4.*a +DISABLED}
  c_b 0.28466892
  addUserKnob {7 c_c t 0.5-a*log(4.*a) +DISABLED}
  c_c 0.55991073
 }
push $N10ffa8f0
push $N10fffe10
 Dot {
  name Dot4
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -776
  ypos 2226
 }
set N1108d170 [stack 0]
 Dot {
  name Dot3
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -556
  ypos 2226
 }
set N11092150 [stack 0]
 Dot {
  name Dot5
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -336
  ypos 2226
 }
 Expression {
  expr0 pow(r,1/gamma)
  expr1 pow(g,1/gamma)
  expr2 pow(b,1/gamma)
  name pow_f3_gamma_26
  label "ACESlib.Utilities_Color.ctl : 260\n// Reverse monitor curve"
  xpos -370
  ypos 2402
  addUserKnob {20 Gamma_tab l Gamma}
  addUserKnob {7 gamma R 0 4}
  gamma 2.6
 }
push $N1108d170
 Expression {
  temp_name0 yb
  temp_expr0 "pow( offs * gamma / ( ( gamma - 1.0) * ( 1.0 + offs)), gamma)"
  temp_name1 rs
  temp_expr1 "pow( ( gamma - 1.0) / offs, gamma - 1.0) * pow( ( 1.0 + offs) / gamma, gamma)"
  expr0 "r >= yb ? ( 1.0 + offs) * pow( r, 1.0 / gamma) - offs : r * rs"
  expr1 "g >= yb ? ( 1.0 + offs) * pow( g, 1.0 / gamma) - offs : g * rs"
  expr2 "b >= yb ? ( 1.0 + offs) * pow( b, 1.0 / gamma) - offs : b * rs"
  name moncurve_r_f3
  label "ACESlib.Utilities_Color.ctl : 260\n// Reverse monitor curve\nmoncurve_r with gamma of 2.4 and offset of 0.055 matches the EOTF found in IEC 61966-2-1:1999 (sRGB)"
  xpos -810
  ypos 2444
  addUserKnob {20 Luminance}
  addUserKnob {7 gamma R 0 4}
  gamma 2.2
  addUserKnob {7 offs}
  offs 0.055
 }
push $N11092150
 Expression {
  temp_name0 c_a
  temp_expr0 "pow( pow( Lw, 1./gamma) - pow( Lb, 1./gamma), gamma)"
  temp_name1 c_b
  temp_expr1 "pow( Lb, 1./gamma) / ( pow( Lw, 1./gamma) - pow( Lb, 1./gamma))"
  expr0 "pow( max( r / c_a, 0.), 1.0/gamma) - c_b"
  expr1 "pow( max( g / c_a, 0.), 1.0/gamma) - c_b"
  expr2 "pow( max( b / c_a, 0.), 1.0/gamma) - c_b"
  name bt1886_r_f3
  label "ACESlib.Utilities_Color.ctl : 301\n// The reference EOTF specified in Rec. ITU-R BT.1886\n// L = a(max\[(V+b),0])^g"
  xpos -590
  ypos 2396
  addUserKnob {20 Luminance}
  addUserKnob {7 Lw R 48 10000}
  Lw 1
  addUserKnob {7 Lb R 0.0001 0.02}
  addUserKnob {7 gamma R 1 4}
  gamma 2.4
 }
push $N1104d610
 Switch {
  inputs 6
  which {{parent.eotf}}
  name EOTF_Switch
  xpos -1250
  ypos 3326
 }
 Expression {
  temp_name0 REFBLACK
  temp_expr0 "64 / 1023"
  temp_name1 REFWHITE
  temp_expr1 "940 / 1023"
  expr0 "r * ( REFWHITE - REFBLACK) + REFBLACK"
  expr1 "g * ( REFWHITE - REFBLACK) + REFBLACK"
  expr2 "b * ( REFWHITE - REFBLACK) + REFBLACK"
  name fullRange_to_smpteRange_f3_
  label "ACESlib.OutputTransforms.ctl : 216"
  xpos -1250
  ypos 3872
  disable {{!parent.legal_range}}
 }
 Output {
  name Output
  xpos -1250
  ypos 4118
 }
push $N10f99880
 Viewer {
  frame_range 1-100
  viewerProcess "sRGB (ACES)"
  name Viewer1
  xpos -920
  ypos -82
  addUserKnob {20 Lock}
  addUserKnob {6 lock_all_buffers l "lock all buffers" -STARTLINE}
  addUserKnob {6 lock_buffer_1 l "lock buffer 1" +STARTLINE}
  addUserKnob {6 lock_buffer_2 l "lock buffer 2" +STARTLINE}
  addUserKnob {6 lock_buffer_3 l "lock buffer 3" +STARTLINE}
  addUserKnob {6 lock_buffer_4 l "lock buffer 4" +STARTLINE}
  addUserKnob {6 lock_buffer_5 l "lock buffer 5" +STARTLINE}
  addUserKnob {6 lock_buffer_6 l "lock buffer 6" +STARTLINE}
  addUserKnob {6 lock_buffer_7 l "lock buffer 7" +STARTLINE}
  addUserKnob {6 lock_buffer_8 l "lock buffer 8" +STARTLINE}
  addUserKnob {6 lock_buffer_9 l "lock buffer 9" +STARTLINE}
  addUserKnob {6 lock_buffer_0 l "lock buffer 0" +STARTLINE}
 }
end_group
